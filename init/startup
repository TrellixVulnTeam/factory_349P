#!/bin/sh
# Copyright (c) 2014 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

INIT_BASE="$(dirname $(readlink -f $0))"
GOOFY_ROLES=""

export INIT_BASE GOOFY_ROLES

is_enabled() {
  # Returns 0 if this rule is enabled.
  # Returns 1 if this rule if disabled.
  #
  # A rule is disabled if and only if:
  #   1. file "disable-${rule_name}" exists OR
  #   2. file "enable-${rule_name}" doesn't exist AND "${rule_file}" is
  #      not executable
  #
  # Parameters:
  #   rule_file: path to the rule file: "/path/to/${rule_name}.sh"

  local rule_file="$1"
  local rule_dir="$(dirname "$rule_file")"
  local rule_file_name="$(basename "${rule_file}")"
  local rule_name="${rule_file_name%.sh}"
  local enable_rule="${rule_dir}/enable-${rule_name}"
  local disable_rule="${rule_dir}/disable-${rule_name}"

  if [ -e "${disable_rule}" ]; then
    return 1
  fi
  [ -e "${enable_rule}" -o -x "${rule_file}" ]
}

execute_rules() {
  local init_folder="$1"
  local rule_file="" rule_name="" enable_rule="" disable_rule=""

  for rule_file in "${INIT_BASE}/${init_folder}"/*.sh; do
    [ -e "${rule_file}" ] || continue  # Skip if no rules found.
    rule_name="$(basename "${rule_file%.sh}")"

    if ! is_enabled "${rule_file}"; then
      echo "Skipping disabled ${rule_file}..."
      continue
    fi
    echo "Applying ${rule_file}..."
    if [ -x "${rule_file}" ]; then
      "${rule_file}"
    else
      sh "${rule_file}"
    fi
  done
}

factory_init() {
  echo "[$(date)] Starting ChromeOS factory initialization..."

  execute_rules common.d
  execute_rules iptables.d

  # See factory_main for the path of tag that may disable Goofy.
  local goofy_rule="${INIT_BASE}/main.d/goofy.sh"
  if ! is_enabled "${goofy_rule}"; then
    echo "[$(date)] Initialization finished (Goofy rules are disabled)."
    return
  fi

  # Determine Goofy roles (device or presenter).
  local tag_presenter="${INIT_BASE}/run_goofy_presenter"
  local tag_device="${INIT_BASE}/run_goofy_device"
  local role

  [ -f "${tag_device}" ] && GOOFY_ROLES="${GOOFY_ROLES} device"
  [ -f "${tag_presenter}" ] && GOOFY_ROLES="${GOOFY_ROLES} presenter"
  [ -z "${GOOFY_ROLES}" ] && GOOFY_ROLES="${GOOFY_ROLES} device monolithic"
  echo "Goofy roles: ${GOOFY_ROLES}"

  for role in ${GOOFY_ROLES}; do
    execute_rules goofy.d/${role}
  done
  echo "[$(date)] All initialization finished."
}

factory_main() {
  echo "[$(date)] Starting ChromeOS factory main program..."
  execute_rules main.d
  # Unlike factory_init, the main programs may need to run in parallel for a
  # long time and occupy the session time of factory.conf so we have to wait
  # until all children processes finished.
  wait
  echo "[$(date)] All main programs finished. Stopped."
}

main() {
  exec 2>&1
  mkdir -p /var/log
  log_file=/var/log/factory-init.log
  local mode="init"

  if [ "$#" -gt 0 ]; then
    mode="$1"
  fi

  case "${mode}" in
    main )
      # Developers may try to start factory main several times so we want to
      # append the logs.
      factory_main | tee -a "${log_file}"
      ;;
    init )
      # Init should be invoked only one time so we want to re-create the logs.
      factory_init | tee "${log_file}"
      ;;
    * )
      echo "Unknown mode: ${mode}." | tee "${log_file}"
      exit 1
      ;;
  esac
}

main "$@"
