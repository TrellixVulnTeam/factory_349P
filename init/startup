#!/bin/sh
# Copyright (c) 2014 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

INIT_BASE="$(dirname $(readlink -f $0))"
GOOFY_ROLES=""

export INIT_BASE GOOFY_ROLES

execute_rules() {
  local init_folder="$1"
  local rule_file="" rule_name="" enable_rule="" disable_rule=""

  for rule_file in "${INIT_BASE}/${init_folder}"/*.sh; do
    [ -e "${rule_file}" ] || continue  # Skip if no rules found.
    rule_name="$(basename "${rule_file%.sh}")"
    enable_rule="${INIT_BASE}/${init_folder}/enable-${rule_name}"
    disable_rule="${INIT_BASE}/${init_folder}/disable-${rule_name}"
    if [ -e "${disable_rule}" ]; then
      echo "Skipping disabled ${rule_file}..."
      continue
    fi
    if ! [ -x "${rule_file}" -o -e "${enable_rule}" ]; then
      echo "Skipping default disabled ${rule_file}..."
      continue
    fi
    echo "Applying ${rule_file}..."
    if [ -x "${rule_file}" ]; then
      "${rule_file}"
    else
      sh "${rule_file}"
    fi
  done
}

factory_init() {
  echo "[$(date)] Starting ChromeOS factory initialization..."

  execute_rules common.d
  execute_rules iptables.d

  # See factory_main for the path of tag that may disable Goofy.
  local disable_goofy="${INIT_BASE}/main.d/disable-goofy"
  if [ -e "${disable_goofy}" ]; then
    echo "[$(date)] Initialization finished (Goofy rules are disabled)."
    return
  fi

  # Determine Goofy roles (device or presenter).
  local tag_presenter="${INIT_BASE}/run_goofy_presenter"
  local tag_device="${INIT_BASE}/run_goofy_device"
  local role

  [ -f "${tag_device}" ] && GOOFY_ROLES="${GOOFY_ROLES} device"
  [ -f "${tag_presenter}" ] && GOOFY_ROLES="${GOOFY_ROLES} presenter"
  [ -z "${GOOFY_ROLES}" ] && GOOFY_ROLES="${GOOFY_ROLES} device monolithic"
  echo "Goofy roles: ${GOOFY_ROLES}"

  for role in ${GOOFY_ROLES}; do
    execute_rules goofy.d/${role}
  done
  echo "[$(date)] All initialization finished."
}

factory_main() {
  echo "[$(date)] Starting ChromeOS factory main program..."
  execute_rules main.d
  # Unlike factory_init, the main programs may need to run in parallel for a
  # long time and occupy the session time of factory.conf so we have to wait
  # until all children processes finished.
  wait
  echo "[$(date)] All main programs finished. Stopped."
}

main() {
  exec 2>&1
  mkdir -p /var/log
  log_file=/var/log/factory-init.log
  local mode="init"

  if [ "$#" -gt 0 ]; then
    mode="$1"
  fi

  case "${mode}" in
    main )
      # Developers may try to start factory main several times so we want to
      # append the logs.
      factory_main | tee -a "${log_file}"
      ;;
    init )
      # Init should be invoked only one time so we want to re-create the logs.
      factory_init | tee "${log_file}"
      ;;
    * )
      echo "Unknown mode: ${mode}." | tee "${log_file}"
      exit 1
      ;;
  esac
}

main "$@"
