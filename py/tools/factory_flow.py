#!/usr/bin/env python
#
# Copyright (c) 2013 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import argparse
import logging
import os
import shutil
import stat
import sys
import tempfile

import factory_common  # pylint: disable=W0611
from cros.factory.test import utils
from cros.factory.utils.process_utils import Spawn, TerminateOrKillProcess


DHCPD_CONF_TEMPLATE = '# Generated by ' + __file__ + '''
subnet %(subnet)s netmask %(netmask)s {
  next-server %(host_ip)s;
}
host dut {
  hardware ethernet %(dut_mac)s;
  fixed-address %(dut_ip)s;
}
'''

USAGE = '''
You need an isolated LAN and run DHCP, TFTP, mini-Omaha, and shopfloor servers
for netboot install.  This script takes care of setting up the servers for you.
'''


class FactoryFlow(object):
  '''Sets up environment for factory install process.'''

  args = None
  bundle_dir = None
  dhcpd = None
  tftpd = None
  download_server = None
  shopfloor_server = None

  def Main(self):
    if not utils.in_chroot():
      sys.exit('Please run this script from within the chroot.')

    try:
      self.ParseArgs()
      self.StartDHCPServer()
      self.StartTFTPServer()
      self.StartDownloadServer()
      self.StartShopfloorServer()
      self.StartFactoryInstall()

      for process in (self.dhcpd, self.tftpd, self.download_server,
                      self.shopfloor_server):
        if process is not None:
          process.wait()
    finally:
      for process in (self.dhcpd, self.tftpd, self.download_server,
                      self.shopfloor_server):
        if process is not None:
          TerminateOrKillProcess(process)

  def ParseArgs(self):
    parser = argparse.ArgumentParser(description=USAGE)
    parser.add_argument(
        '--dhcp_iface',
        help='Network interface on which to run DHCP server')
    parser.add_argument(
        '--host_ip',
        help='The IP address to assign to the DHCP network interface')
    parser.add_argument(
        '--dut_mac',
        help='The MAC address of DUT or ethernet dongle.')
    parser.add_argument(
        '--dut_ip',
        help='The IP address to assign to DUT')
    parser.add_argument(
        '--subnet',
        help='The subnet of the testing LAN')
    parser.add_argument(
        '--netmask', default='255.255.255.0',
        help='The netmask of the testing LAN')
    parser.add_argument(
        '--no-dhcp', dest='dhcp', action='store_false',
        help='Do not start DHCP server')
    parser.add_argument(
        '--no-tftp', dest='tftp', action='store_false',
        help='Do not start TFTP server')
    parser.add_argument(
        '--no-download', dest='download', action='store_false',
        help='Do not start download (mini-Omaha) server')
    parser.add_argument(
        '--no-shopfloor', dest='shopfloor', action='store_false',
        help='Do not start shopfloor server')
    parser.add_argument(
        'dir', metavar='BUNDLE_DIR',
        help='Directory conatining the finalized bundle')
    self.args = parser.parse_args()
    self.bundle_dir = os.path.realpath(self.args.dir)

    logging.basicConfig(level=logging.INFO)

  def StartDHCPServer(self):
    if not self.args.dhcp:
      return
    else:
      required_args = ('dhcp_iface', 'host_ip', 'dut_mac', 'dut_ip')
      if not all([getattr(self.args, arg) for arg in required_args]):
        sys.exit('Please specify the following arguments for DHCP server: ' +
                 ', '.join(required_args))
      if not self.args.subnet:
        self.args.subnet = self.args.host_ip.rsplit('.', 1)[0] + '.0'

    cfg = tempfile.NamedTemporaryFile(prefix='dhcpd_', suffix='.conf',
                                      delete=False)
    cfg.write(DHCPD_CONF_TEMPLATE % dict(host_ip=self.args.host_ip,
                                         dut_mac=self.args.dut_mac,
                                         dut_ip=self.args.dut_ip,
                                         subnet=self.args.subnet,
                                         netmask=self.args.netmask))
    cfg.flush()
    lease = tempfile.NamedTemporaryFile(prefix='dhcpd_', suffix='.leases',
                                        delete=False)
    Spawn(['touch', lease.name], check_call=True, log=True)

    logging.info('Starting DHCP server on %s using config %s',
                 self.args.dhcp_iface, cfg.name)
    Spawn(['/sbin/ifconfig', self.args.dhcp_iface, self.args.host_ip],
          check_call=True, log=True, sudo=True)
    self.dhcpd = Spawn(['/usr/sbin/dhcpd', '-f', '--no-pid', '-cf', cfg.name,
                        '-lf', lease.name, self.args.dhcp_iface],
                       log=True, sudo=True)

  def StartTFTPServer(self):
    if not self.args.tftp:
      return
    elif not self.args.host_ip:
      sys.exit('Please specify host_ip for TFTP server')

    tftp_dir = tempfile.mkdtemp(prefix='tftp_')
    tftpboot = os.path.join(tftp_dir, 'tftpboot')
    utils.TryMakeDirs(tftpboot)
    vmlinux_src = os.path.join(self.bundle_dir, 'factory_shim', 'netboot',
                               'vmlinux.uimg')
    vmlinux_dest = os.path.join(tftpboot, 'vmlinux.uimg')
    shutil.copy(vmlinux_src, vmlinux_dest)
    os.chmod(tftp_dir, stat.S_IRWXU | stat.S_IXOTH)
    os.chmod(tftpboot, stat.S_IRWXU | stat.S_IXOTH)
    os.chmod(vmlinux_dest,
             stat.S_IWUSR | stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH)

    logging.info('Starting TFTP server serving %s', tftp_dir)
    self.tftpd = Spawn(['/usr/sbin/in.tftpd', '-L', '-s', tftp_dir,
                        '--address', '%s:69' % self.args.host_ip],
                       log=True, sudo=True)

  def StartDownloadServer(self):
    if not self.args.download:
      return

    self.download_server = Spawn(
        [os.path.join(self.bundle_dir, 'start_download_server.sh')],
        log=True)

  def StartShopfloorServer(self):
    if not self.args.shopfloor:
      return

    self.shopfloor_server = Spawn(
        [os.path.join(self.bundle_dir, 'shopfloor', 'start_mock_shopfloor')],
        log=True, sudo=True)

  def StartFactoryInstall(self):
    logging.info('Please flash netboot firmware to DUT to start factory '
                 'install process')


if __name__ == '__main__':
  FactoryFlow().Main()
