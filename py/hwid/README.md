# ChromeOS HWID Database User Guide

This document is aimed at defining the standard way to update the HWID database.

## Introduction to HWID Database

The role of a hardware ID (HWID) configuration file is to verify that every
hardware component used in a Chrome device is qualified. The config file mainly
lists the phase of the device `image_id`, the pattern of the encoded string
`pattern`, the mapping of bit value to the component `encoded_field`, and the
probe result of each component `component`.
For convenience, we call the HWID config file **HWID database**.

## Update Rule

The HWID database has two tasks: (1) verifies the probe result and generates the
HWID string when building new devices at the factory, and (2) decodes the HWID
string generated by every previous version of the database. To ensure the new
database can successfully decode the old HWID string, there are some rules while
updating the database.

### 1. Common Rule: Only Append, Do Not Modify or Remove Items
The first common rule is: do not remove anything. Because we not only need to
decode current HWID, but also need to decode *EVERY* previous valid HWID. Only
these items can be modified:
- The probeable attribute of the component
- The status of the component item
- The rules items

### 2. Pattern: Do Not Modify the Set of encoded_field
It's obvious that we are not allowed to remove the field in the pattern. Adding
a field whose component class is new seems not break the previous HWID, but it
actually causes ambiguity. After adding the component in the pattern, we would
decode old HWID as index = 0. But actually we have no information about this
component in old HWID. There are 3 possible situations:

1. The old device doesn't have the component, so the component is not in the
   HWID database.
2. The old device has the component, but it cannot be probed previously.
3. The old device has the component and it can be probed, but user forgot to
   add into HWID database.

Most of the case is 1, the old device doesn't have the component. But we don't
enforce index 0, which means there is no probed result (or no component)
currently. So it is weird to allow this happen. The reasonable way is: the
component set in each pattern cannot be modified. It can prevent this ambiguity
from happening. In summary, when we need to modify the set of component class,
create a new pattern.

### 3. Encoded_fields: Do Not Modify Encoded Mapping
Because `encoded_field` is shared with all patterns, the existed items in the
`encoded_field` cannot be modified. Otherwise the old HWID cannot lookup the
correct mapping. Therefore, if we need to change the mapping of a component, we
can only add new field into `encoded_fields`.

### 4. Components: Use deprecated/unsupported to Remove Component
Because the components items should be encoded in `encoded_field` in normal
case, we cannot remove them. When we don't allow a component in the new unit,
use deprecated status. If you don't even allow to match it, use unsupported
status.

### 5. Meaning of "probeable: False"
When do we use "probeable: False", it means one of these:

- The component class is removed at the latest pattern.
- The value is determined at the evaluation time. Set at rule.
- Exception: If there is only one item in this component class, set the index
  to 0. It is only for backward compatibility.
  *Please use "default" argument instead of using this.*


## Database Builder

Originally it was tedious to convert the probe result to HWID database. Most of
the time we copy and paste it from an existing project and modify the probe
value. In addition, there are many implict rules and relations between each
section. For example, the number of bits in the field of the pattern should be
large enough to contain all items in the encoded field.

Now we have a tool called **database builder** to generate or update the HWID
database. This tool is aimed at covering most of the common and tedious HWID
database change, like adding or removing components. But the HWID database still
needs to be manually updated in the following scenarios:

### Scenarios that Cannot Use Database Builder

- **Multiple image_ids are active**

  In the database builder, we assume that only the latest (maximum) `image_id`
  is active. So we recommend not to use the tool if the assumption is not true.

- **Modify the rules**

  The rule section gives us much flexibility in assigning and verifying the
  value of the component. On the other hand, there is no universal diagram for
  the rule section. We still leave it to user update the rules manually.

- **Change the status of component items**

  Because changing the status is quite easy. Just change it :)

### Command of Database Builder

```shell
# Build the HWID database
$ hwid build-database \
    --board <board name> \
    --output-database-path <output folder> \
    --probed-results-file <probed result file> \
    --image-id <IMAGE_ID> \  # Name of the image_id
    [--add-comp COMPS [COMPS ...]] \  # Add the default item
    [--del-comp COMPS [COMPS ...]] \  # Delete the component
    [--region REGION [REGION ...]] \  # Add supported regions
    [--customization-id ID1 [ID2 ...]] \  # Add supported customization_id

# Update the HWID database
$ hwid update-database \
    --board <board name> \
    --output-database-path <output folder> \
    [--probed-results-file <probed result file>] \
    [--output-database <output file>] \  # Write into different file
    [--image-id <IMAGE_ID>] \  # Name of the image_id
    [--add-comp COMPS [COMPS ...]] \  # Add the default item
    [--del-comp COMPS [COMPS ...]] \  # Delete the component
    [--region REGION [REGION ...]] \  # Add supported regions
    [--customization-id ID1 [ID2 ...]] \  # Add supported customization_id
```

### Post-Processing
Though the database builder handle most of the work, there is still some
manual post-processing.

- **Check the name of component items**

  The builder will decide a name by the probe result, but it might be
  meaningless. Please change the name in **encoded_fields** and **components**
  if you don't like it.

- **Confirm the status of the component items**

  All component items generated by the database builder are **unqualified**.
  After the SIE or TAM confirms the component is qualified at AVL, please change
  the status to **supported**.


## Use Cases

Below, we will list some common use cases of HWID database change, and provide
the recommendation way to do it.

### Create A New HWID Database
At the beginning of the project, we need to create a new HWID database. The
easiest way is using the database builder with a valid probe result. We also
need this information: board name and phase. Here is an example to create a
product named "GOOGLE" with the phase "EVT".

```shell
# Get the probe result.
$ gooftool probe --include_vpd > /tmp/probe.yaml

# Create the database at /usr/local/factory/hwid/GOOGLE
$ hwid build-database \
    --probed-results-file /tmp/probe.yaml \
    --output-database-path /usr/local/factory/hwid \
    --board GOOGLE \
    --image-id EVT
```

### Probing Result Is Not Ready or Confirmed
When we bring up a device, the probing code for some hardware components might
not be ready. For example, a device cannot probe cellular in EVT build, and can
probe it in DVT build. Besides, we still might have no-cellular SKU in DVT
build. In this case we need to determine:
1. There is cellular at DUT but we cannot probe in EVT build
2. No cellular in DVT build
3. Has cellular in DVT build
Here we assume that there is only ONE SKU when we cannot probe the component.
That is, in EVT build we only have one SKU that has the same cellular component.
Then the HWID database in EVT and DVT should be like:

```yaml
# EVT
image_id:
  0: EVT

pattern:
- image_ids: [0]
  encoding_scheme: base8192
  fields:
  - cellular_field: 3

encoded_fields:
  cellular_field:
    0: {cellular: cellular_default}

components:
  cellular:
    items:
      cellular_default:
        default: True
        status: unqualified
        value: NULL
```
```yaml
# DVT
image_id:
  0: EVT
  1: DVT

pattern:
- image_ids: [0, 1]
  encoding_scheme: base8192
  fields:
  - cellular_field: 3

encoded_fields:
  cellular_field:
    0: {cellular: cellular_default}
    1: {cellular: aa}
    2: {cellular: NULL}

components:
  cellular:
    items:
      cellular_default:
        default: True
        status: unsupported
        value: NULL
      aa:
        value: {compact_str: aa}
```

### Add Second Source and Update Firmware
This is the most common update in HWID database. When we introduce second source
or update firmware version, we need to add new supported component item into
HWID database. Just append the new item in the component field and check if the
encoding bit is enough or not. If we update the firmware version, we should mark
old one "deprecated" to ensure all DUTs in the factory use the latest firmware.

<!--- TODO(akahuang): Fill the example.  -->

### Deprecate Component Item
Deprecating the component item is quite easy. Just add "status: deprecated" in
the target component item. Then the new unit may not use this component item.

<!--- TODO(akahuang): Fill the example.  -->

### Add New Component in Device
We might add new components during the builds. For example, we don't have
cellular in EVT build, but decide to add cellular in DVT build. To complicate
the situation even more, in DVT build we might have one SKU that has cellular
and another SKU that doesn't. In this case, we need to distinguish:
1. No cellular in EVT build
2. No cellular in DVT build
3. Has cellular in DVT build
The difference between 1 and 2 is: in EVT build we don't check the probed result
of the cellular component. The actual meaning should be "we don't have
information about cellular" instead of "this device doesn't have cellular".

To distinguish the case 1 and 2, we need to create a new pattern that adds
the new component, while retaining the old pattern which lacks the component.
Please see "Update Rule 2" for detail.

<!--- TODO(akahuang): Fill the example.  -->

### Delete Existed Component in Device
Similar to adding a new component in the device, we might decide to remove a
component during the build. For example, the device has cellular in EVT, but we
decide to remove it in DVT. To ensure that we can still decode the previous
HWID, we cannot remove it from the encoded field and component. We need to add a
new pattern without the cellular encoded bits. The HWID database should be like:

<!--- TODO(akahuang): Fill the example.  -->

### Transfer Legacy Region Style to List Style
We use magic tag `"!region_field"` to generate the region encoded field. There
are two styles: legacy and list style. In legacy style, each region has its own
index mapping. For example, "us" maps to 29 and "gb" maps to 16. However, in
list style, only the listed regions are encoded. In the example below,
"us" maps to 1 and "gb" maps to 2.

<!--- TODO(akahuang): Fill the example.  -->

Because the update rule, we cannot just replace the legacy style because the
encoding mapping is different. If we want to transfer legacy style to list
style, we need to create another `encoded_field` and remove the old one. For
example:

<!--- TODO(akahuang): Fill the example.  -->

### Combine the Component Items
It's a common issue that the component has multiple probed results, but we don't
notice it at first. So we create multiple component items for the same
component. For example, the driver might add ".[1-9].auto" randomly in the
probed result. For this situation, we should add the correct item and then set
the wrong items to invisible. Like:

<!--- TODO(akahuang): Fill the example.  -->
